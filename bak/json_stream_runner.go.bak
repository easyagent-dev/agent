package bak

import (
	"context"
	"easymvp_api/internal/llm"
	utils2 "easymvp_api/internal/utils"
	_ "embed"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/duke-git/lancet/v2/pointer"
	"github.com/duke-git/lancet/v2/xerror"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

type AgentStep struct {
	Reasoning string        `json:"reasoning" jsonschema:"title=Reasoning,description=The reasoning process of the agent before making a tool call,required"`
	ToolCall  *llm.ToolCall `json:"toolCall" jsonschema:"title=Tool Call,description=The tool call to be executed by the agent,required"`
}

// JsonStreamRunner is responsible for executing an agent with JSON streaming output
type JsonStreamRunner struct {
	agent                 *Agent
	logger                *zap.Logger
	modelProviderRegistry llm.ModelRegistry
	useJsonSchema         bool
}

var _ Runner = (*JsonStreamRunner)(nil)

// NewJsonStreamRunner creates a new JSON stream runner with the provided configuration
func NewJsonStreamRunner(agent *Agent, logger *zap.Logger, modelProviderRegistry llm.ModelRegistry, useJsonSchema bool) (Runner, error) {
	return &JsonStreamRunner{
		agent:                 agent,
		logger:                logger,
		modelProviderRegistry: modelProviderRegistry,
		useJsonSchema:         useJsonSchema,
	}, nil
}

// Run executes the agent with the given content using JSON streaming
func (r *JsonStreamRunner) Run(ctx context.Context, messages []*llm.Message, maxIterations int, callback Callback) (*AgentResponse, error) {
	var results *string = nil

	toolRegistry := NewToolRegistry()
	for _, tool := range r.agent.Tools {
		if err := toolRegistry.RegisterTool(tool); err != nil {
			return nil, fmt.Errorf("failed to register tool: %w", err)
		}
	}

	_ = toolRegistry.RegisterTool(NewModelOutputTool(r.agent.OutputSchema, r.agent.OutputUsage))
	tools := toolRegistry.GetTools()

	var responseFormat *llm.ResponseFormat
	var jsonSchema interface{}

	if r.useJsonSchema {
		responseFormat = pointer.Of(llm.ResponseFormatJsonSchema)
		jsonSchema = llm.GenerateSchema[AgentStep]()
	} else {
		responseFormat = pointer.Of(llm.ResponseFormatJson)
		jsonSchema = nil
	}
	modelInstance, err := r.modelProviderRegistry.GetModel(ctx, r.agent.ModelProvider, r.agent.Model, &llm.ModelConfig{
		ThreadID:         r.agent.ThreadID,
		Temperature:      r.agent.Temperature,
		TopP:             r.agent.TopP,
		MaxTokens:        r.agent.MaxTokens,
		PresencePenalty:  r.agent.PresencePenalty,
		FrequencyPenalty: r.agent.FrequencyPenalty,
		Seed:             r.agent.Seed,
		ReasoningEffort:  r.agent.ReasoningEffort,
		Stop:             r.agent.Stop,
		Cache:            r.agent.Cache,
		Expires:          r.agent.Expires,
		ResponseFormat:   responseFormat,
		JSONSchema:       jsonSchema,
	})
	if err != nil {
		return nil, xerror.Wrap(err, "failed to get model provider")
	}

	userMessage := messages[len(messages)-1]
	if userMessage.Role != llm.RoleUser {
		return nil, xerror.New("last message is not user message")
	}

	agentContext := &AgentContext{
		Agent:         r.agent,
		Messages:      messages,
		Callback:      callback,
		ModelRegistry: r.modelProviderRegistry,
		ToolCalls:     []*ToolCall{},
	}
	ctx = WithAgentContext(ctx, agentContext)

	usage := &llm.TokenUsage{}
	totalCost := 0.0

	completed := false
	emptyToolCalled := false
	for i := 0; i < maxIterations && !completed; i++ {
		prompts, err := GetJsonAgentSystemPrompt(r.agent, userMessage, tools)

		if err != nil {
			return nil, xerror.Wrap(err, "failed to create prompts")
		}

		callback.OnModel(ctx, r.agent.ModelProvider, r.agent.Model, prompts, messages)

		stream, err := modelInstance.StreamGenerateContent(ctx, prompts, messages, tools)
		if err != nil {
			return nil, xerror.Wrap(err, "failed to call model completion")
		}

		parser := NewAgentStepJsonParser()
		streamClosed := false

		var toolCall *ToolCall
		for {
			if streamClosed || completed || toolCall != nil {
				break
			}
			select {
			case chunk, ok := <-stream:
				if !ok || chunk == nil {
					streamClosed = true
					break
				}
				chunkType := chunk.Type()
				if chunkType == llm.UsageChunkType {
					usageChunk := chunk.(llm.StreamUsageChunk)
					if usageChunk.Usage != nil {
						usage.Append(usageChunk.Usage)
					}
					if usageChunk.Cost != nil {
						totalCost += *usageChunk.Cost
					}
				} else if chunkType == llm.TextChunkType {
					textChunk := chunk.(llm.StreamTextChunk)
					content := textChunk.Text
					r.logger.Info("content", zap.String("content", content))
					parser.Append(content)

					blocks, err := parser.ParseNext()
					if err != nil {
						return nil, xerror.Wrap(err, "failed to parse blocks")
					}

					for _, block := range blocks {
						if block.Type == AgentEventTypeText || block.Type == AgentEventTypeReasoning {
							callback.OnReasoning(ctx, block)
						} else if block.Type == AgentEventTypeUseTool {
							if block.Partial {
								partialToolCall := &ToolCall{
									ID:     uuid.New().String(),
									Name:   block.Attributes["name"],
									Params: block.Content,
								}
								callback.OnToolCallPartial(ctx, partialToolCall.Name, partialToolCall.Params)
							} else {
								toolCall = &ToolCall{
									ID:     uuid.New().String(),
									Name:   block.Attributes["name"],
									Params: block.Content,
								}

								tool, err := toolRegistry.GetTool(toolCall.Name)
								toolCallId := uuid.New().String()
								if err != nil {
									return nil, xerror.Wrap(err, "failed to get tool, "+toolCall.Name)
								}
								r.logger.Debug("Agent tool use",
									zap.String("tool", toolCall.Name),
									zap.String("params", toolCall.Params))

								if strings.Contains(toolCall.Params, "google") {
									usage.TotalWebSearches += 1
								}

								messages = append(messages, &llm.Message{
									Role:    llm.MessageRoleAssistant,
									Content: "",
									ToolCall: &llm.ToolCall{
										ID:    toolCallId,
										Name:  toolCall.Name,
										Input: toolCall.Params,
									},
								})
								callback.OnToolCallStart(ctx, toolCall.Name, toolCall.Params)

								callback.OnReasoning(ctx, &AgentEvent{
									Type:    AgentEventTypeReasoning,
									Content: "\n\n[tool] call " + toolCall.Name,
								})

								timestamp := time.Now().UnixMilli()
								toolResults, err := tool.Run(ctx, toolCall.Params)
								agentContext.ToolCalls = append(agentContext.ToolCalls, &ToolCall{
									ID:     toolCallId,
									Name:   toolCall.Name,
									Params: toolCall.Params,
								})
								if err != nil {
									messages = append(messages, &llm.Message{
										Role:    llm.MessageRoleTool,
										Content: "",
										ToolCall: &llm.ToolCall{
											ID:      toolCallId,
											Name:    toolCall.Name,
											Results: pointer.Of("tool call failed: " + err.Error()),
										},
									})
									callback.OnReasoning(ctx, &AgentEvent{
										Type:    AgentEventTypeReasoning,
										Content: " failed, " + err.Error() + ", in " + strconv.FormatInt(time.Now().UnixMilli()-timestamp, 10) + "ms\n\n",
									})
								} else {
									if toolResults == "" {
										messages = append(messages, &llm.Message{
											Role:    llm.MessageRoleTool,
											Content: "",
											ToolCall: &llm.ToolCall{
												ID:      toolCallId,
												Name:    toolCall.Name,
												Results: pointer.Of("tool call successfully with no results"),
											},
										})
									} else {
										messages = append(messages, &llm.Message{
											Role:    llm.MessageRoleTool,
											Content: "",
											ToolCall: &llm.ToolCall{
												ID:      toolCallId,
												Name:    toolCall.Name,
												Results: pointer.Of(toolResults),
											},
										})
									}
									callback.OnReasoning(ctx, &AgentEvent{
										Type:    AgentEventTypeReasoning,
										Content: " completed, in " + strconv.FormatInt(time.Now().UnixMilli()-timestamp, 10) + "ms\n\n",
									})
								}
								callback.OnToolCallEnd(ctx, toolCall.Name, toolCall.Params, toolResults)
								if toolCall.Name == CompleteTaskToolName {
									completed = true
									results = &toolResults
								}
							}

						}
					}
				} else {
					return nil, fmt.Errorf("unknown chunk type: %s", string(chunkType))
				}
			}
		}
		if toolCall == nil {
			if emptyToolCalled {
				return nil, xerror.New("model doesn't support the tool call")
			} else {
				emptyToolCalled = true
				messages = append(messages, &llm.Message{
					Role:    llm.RoleUser,
					Content: "You didn't reply anything, You MUST call a tool get information or call complete_task tool to return reply to user",
				})
			}
		}
	}

	if results == nil {
		r.logger.Error("Agent exceeded max iterations", zap.Int("maxIterations", maxIterations))
		return nil, xerror.New("agent exceeded max iterations")
	}

	runnerOutput := &AgentResponse{
		Output: *results,
		Usage:  usage,
		Cost:   &totalCost,
	}

	callback.OnUsage(ctx, r.agent.ModelProvider, r.agent.Model, runnerOutput.Usage)
	r.logger.Info("Agent run completed successfully")
	return runnerOutput, nil
}

